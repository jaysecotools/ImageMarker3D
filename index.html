<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Image Marker Tool</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* [KEEP ALL YOUR EXISTING STYLES HERE - DON'T CHANGE THEM] */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { display: flex; flex-direction: column; height: 100vh; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #e6e6e6; overflow: hidden; }
        .header { background: rgba(0, 0, 0, 0.7); padding: 15px 20px; border-bottom: 2px solid #00b4d8; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .header h1 { color: #00b4d8; font-size: 1.8rem; }
        .header h1 i { margin-right: 10px; }
        .main-container { display: flex; flex: 1; overflow: hidden; }
        .left-panel { width: 320px; background: rgba(30, 30, 46, 0.9); padding: 20px; overflow-y: auto; border-right: 1px solid #444; flex-shrink: 0; }
        .panel-section { margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px solid #444; }
        .panel-section h3 { color: #00b4d8; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
        .upload-area { border: 3px dashed #00b4d8; border-radius: 10px; padding: 30px 20px; text-align: center; cursor: pointer; transition: all 0.3s; background: rgba(0, 180, 216, 0.05); margin-bottom: 20px; }
        .upload-area:hover { background: rgba(0, 180, 216, 0.1); border-color: #90e0ef; }
        .upload-area i { font-size: 48px; color: #00b4d8; margin-bottom: 15px; }
        .upload-area p { margin: 10px 0; }
        .upload-area .file-info { font-size: 0.9rem; color: #aaa; }
        .button { display: block; width: 100%; padding: 12px; margin: 10px 0; border: none; border-radius: 6px; background: #00b4d8; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s; text-align: center; }
        .button:hover { background: #0077b6; transform: translateY(-2px); }
        .button.secondary { background: #444; }
        .button.secondary:hover { background: #555; }
        .button.danger { background: #e63946; }
        .button.danger:hover { background: #d00000; }
        .button i { margin-right: 8px; }
        .marker-form input, .marker-form textarea, .marker-form select { width: 100%; padding: 10px; margin-bottom: 12px; border: 1px solid #555; border-radius: 4px; background: rgba(255, 255, 255, 0.1); color: white; }
        .marker-form textarea { height: 80px; resize: vertical; }
        .marker-type-selector { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px; }
        .marker-type { padding: 10px; border: 2px solid transparent; border-radius: 6px; text-align: center; cursor: pointer; transition: all 0.2s; background: rgba(255, 255, 255, 0.05); }
        .marker-type.selected { border-color: #00b4d8; background: rgba(0, 180, 216, 0.1); }
        .marker-type i { font-size: 20px; margin-bottom: 5px; display: block; }
        .marker-type.info { color: #4cc9f0; }
        .marker-type.link { color: #4361ee; }
        .marker-type.video { color: #f72585; }
        .marker-type.audio { color: #7209b7; }
        .marker-type.warning { color: #f8961e; }
        .marker-type.question { color: #2a9d8f; }
        .marker-list { max-height: 300px; overflow-y: auto; }
        .marker-item { background: rgba(255, 255, 255, 0.05); border-left: 4px solid #00b4d8; padding: 12px; margin-bottom: 10px; border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .marker-item:hover { background: rgba(255, 255, 255, 0.1); }
        .marker-item.selected { background: rgba(0, 180, 216, 0.15); }
        .marker-item-header { display: flex; justify-content: space-between; align-items: center; }
        .marker-item-title { font-weight: bold; display: flex; align-items: center; gap: 8px; }
        .marker-item-type { font-size: 0.8rem; padding: 2px 8px; border-radius: 10px; background: rgba(255, 255, 255, 0.1); }
        .marker-item-description { font-size: 0.9rem; color: #aaa; margin-top: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .marker-item-actions { display: flex; gap: 5px; margin-top: 10px; }
        .marker-action-btn { padding: 4px 10px; border: none; border-radius: 4px; font-size: 0.8rem; cursor: pointer; }
        .marker-action-btn.edit { background: #00b4d8; color: white; }
        .marker-action-btn.delete { background: #e63946; color: white; }
        .viewer-container { flex: 1; position: relative; overflow: hidden; }
        #viewer { width: 100%; height: 100%; }
        .viewer-overlay { position: absolute; top: 20px; left: 20px; z-index: 10; }
        .viewer-controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 10; }
        .control-btn { background: rgba(0, 0, 0, 0.7); color: white; border: none; width: 50px; height: 50px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; transition: all 0.3s; }
        .control-btn:hover { background: rgba(0, 180, 216, 0.8); transform: scale(1.1); }
        .instructions { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.8); padding: 30px; border-radius: 10px; max-width: 500px; z-index: 5; }
        .instructions h3 { color: #00b4d8; margin-bottom: 15px; }
        .hidden { display: none !important; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .modal { background: #1a1a2e; padding: 30px; border-radius: 10px; max-width: 800px; width: 90%; max-height: 80vh; overflow-y: auto; border: 2px solid #00b4d8; }
        .modal h3 { color: #00b4d8; margin-bottom: 20px; text-align: center; }
        .modal textarea { width: 100%; height: 400px; padding: 15px; background: rgba(255, 255, 255, 0.05); border: 1px solid #444; border-radius: 5px; color: white; font-family: monospace; font-size: 12px; margin-bottom: 20px; resize: none; white-space: pre; overflow-x: auto; }
        .modal-buttons { display: flex; gap: 10px; justify-content: center; }
        
        /* Add preview indicator style */
        .preview-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 3px solid #00ff00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            opacity: 0.7;
            display: none;
            box-shadow: 0 0 10px #00ff00;
        }
        .preview-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: #00ff00;
            border-radius: 50%;
        }
        
.instructions { 
    border: 2px solid #00b4d8;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
}

        /* Cursor style for marker placement */
        .marker-cursor {
            cursor: crosshair !important;
        }
        
        /* NEW: In-world marker info panel */
        .marker-info-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #00b4d8;
            max-width: 300px;
            min-width: 250px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s ease;
            font-size: 14px;
        }
        
        .marker-info-panel h4 {
            color: #00b4d8;
            margin: 0 0 10px 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .marker-info-panel p {
            margin: 8px 0;
            line-height: 1.4;
        }
        
        .marker-info-panel a {
            color: #4cc9f0;
            text-decoration: none;
            display: inline-block;
            margin-top: 10px;
            padding: 6px 12px;
            background: rgba(76, 201, 240, 0.1);
            border-radius: 4px;
            transition: background 0.3s;
        }
        
        .marker-info-panel a:hover {
            background: rgba(76, 201, 240, 0.2);
        }
        
        .marker-info-panel .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: transparent;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 18px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .marker-info-panel .close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        @media (max-width: 1024px) { .main-container { flex-direction: column; } .left-panel { width: 100%; max-height: 40vh; } }
        @media (max-width: 768px) { .header { flex-direction: column; gap: 10px; text-align: center; } .marker-type-selector { grid-template-columns: repeat(2, 1fr); } }
    </style>
</head>
<body>
    <div class="header">
        <h1><i class="fas fa-globe-americas"></i> 360° Image Marker Tool</h1>
        <div class="header-controls">
            <button class="button secondary" id="exportBtn">
                <i class="fas fa-file-export"></i> Export as HTML
            </button>
        </div>
    </div>

    <div class="main-container">
        <div class="left-panel">
            <div class="panel-section">
                <h3><i class="fas fa-upload"></i> Upload 360° Image</h3>
                <div class="upload-area" id="uploadArea">
                    <i class="fas fa-cloud-upload-alt"></i>
                    <p>Click or drag & drop to upload 360° image</p>
                    <p class="file-info">Supported: JPG, PNG (Equirectangular format)</p>
                    <input type="file" id="fileInput" accept=".jpg,.jpeg,.png,.webp" style="display: none;">
                </div>
                <div id="imageInfo" class="hidden">
                    <p><strong>Current Image:</strong> <span id="currentImageName">None</span></p>
                    <p><strong>Markers:</strong> <span id="markerCount">0</span></p>
                </div>
            </div>

            <div class="panel-section">
                <h3><i class="fas fa-map-marker-alt"></i> Add Marker</h3>
                <div class="marker-type-selector" id="markerTypeSelector">
                    <div class="marker-type info selected" data-type="info"><i class="fas fa-info-circle"></i><span>Info</span></div>
                    <div class="marker-type link" data-type="link"><i class="fas fa-link"></i><span>Link</span></div>
                    <div class="marker-type video" data-type="video"><i class="fas fa-video"></i><span>Video</span></div>
                    <div class="marker-type audio" data-type="audio"><i class="fas fa-volume-up"></i><span>Audio</span></div>
                    <div class="marker-type warning" data-type="warning"><i class="fas fa-exclamation-triangle"></i><span>Warning</span></div>
                    <div class="marker-type question" data-type="question"><i class="fas fa-question-circle"></i><span>Question</span></div>
                </div>
                
                <p style="margin-bottom: 15px; font-size: 0.9rem; color: #aaa;">
                    <i class="fas fa-mouse-pointer"></i> Select marker type above, then click on the image to place it
                </p>
                
                <div class="marker-form" id="markerForm">
                    <input type="text" id="markerTitle" placeholder="Marker Title" maxlength="50">
                    <textarea id="markerDescription" placeholder="Description (optional)"></textarea>
                    <input type="text" id="markerUrl" placeholder="URL (for links/media)" class="hidden">
                    
                    <div class="form-buttons">
                        <button class="button" id="saveMarkerBtn"><i class="fas fa-save"></i> Save Marker</button>
                        <button class="button secondary" id="cancelMarkerBtn"><i class="fas fa-times"></i> Cancel</button>
                        <button class="button danger" id="deleteMarkerBtn" style="display: none;"><i class="fas fa-trash"></i> Delete Marker</button>
                    </div>
                </div>
                
                <div class="placement-status" id="placementStatus" style="margin-top: 15px; padding: 10px; background: rgba(0, 180, 216, 0.1); border-radius: 4px; text-align: center; display: none;">
                    <i class="fas fa-mouse-pointer"></i> <strong>Ready to place marker</strong>
                    <p style="font-size: 0.9rem; margin-top: 5px; color: #aaa;">Click anywhere on the image to place marker</p>
                </div>
            </div>

            <div class="panel-section">
                <h3><i class="fas fa-list"></i> Markers (<span id="markerListCount">0</span>)</h3>
                <input type="text" id="markerSearch" placeholder="Search markers..." style="width: 100%; padding: 10px; margin-bottom: 15px; border-radius: 4px; background: rgba(255, 255, 255, 0.1); border: 1px solid #555; color: white;">
                <div class="marker-list" id="markerList"></div>
                <button class="button danger" id="clearMarkersBtn"><i class="fas fa-trash"></i> Clear All Markers</button>
            </div>

            <div class="panel-section">
                <h3><i class="fas fa-cogs"></i> Viewer Controls</h3>
                <button class="button secondary" id="resetViewBtn"><i class="fas fa-redo"></i> Reset View</button>
                <button class="button secondary" id="autoRotateBtn"><i class="fas fa-sync"></i> Toggle Auto-Rotate</button>
            </div>
        </div>

        <div class="viewer-container">
            <div id="viewer"></div>
            
            <!-- Add preview indicator -->
            <div class="preview-indicator" id="previewIndicator"></div>
            
            <div class="instructions" id="instructions">
                <i class="fas fa-globe-americas" style="font-size: 48px; color: #00b4d8; margin-bottom: 20px;"></i>
                <h3>Welcome to the 360° Image Marker Tool</h3>
                <p>1. Upload a 360° panoramic image (equirectangular format)</p>
                <p>2. Select marker type from the left panel</p>
                <p>3. Click on the image to place markers</p>
                <p>4. Customize markers with titles, descriptions, and URLs</p>
                <p>5. Export as a standalone HTML file for any device</p>
            </div>
            
            <div class="viewer-overlay">
                <div class="viewer-controls">
                    <button class="control-btn" id="placeMarkerBtn" title="Place Marker Mode">
                        <i class="fas fa-map-marker-alt"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay hidden" id="exportModal">
        <div class="modal">
            <h3><i class="fas fa-file-export"></i> Export as Standalone HTML</h3>
            <p>Copy the code below and save it as an HTML file. It contains everything needed to view your 360° image with markers on any device (PC, mobile, VR).</p>
            <textarea id="exportCode" readonly></textarea>
            <div class="modal-buttons">
                <button class="button" id="copyCodeBtn"><i class="fas fa-copy"></i> Copy Code</button>
                <button class="button secondary" id="downloadBtn"><i class="fas fa-download"></i> Download HTML File</button>
                <button class="button secondary" id="closeExportBtn"><i class="fas fa-times"></i> Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, sphere;
        let markers = [];
        let currentMarker = null;
        let selectedMarkerType = 'info';
        let autoRotate = false;
        let currentImageName = '';
        let currentImageDataUrl = '';
        let isMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let previewMarker = null;
        let editingMarkerId = null;
        let placementMode = false;
        let raycaster, mouse;
        let activeInfoPanel = null; // Track active info panel

        const markerTypes = {
            info: { color: 0x4cc9f0, icon: 'fa-info-circle' },
            link: { color: 0x4361ee, icon: 'fa-link' },
            video: { color: 0xf72585, icon: 'fa-video' },
            audio: { color: 0x7209b7, icon: 'fa-volume-up' },
            warning: { color: 0xf8961e, icon: 'fa-exclamation-triangle' },
            question: { color: 0x2a9d8f, icon: 'fa-question-circle' }
        };

function createMarkerIcon(type, color) {
    // Create a canvas for the icon
    const canvas = document.createElement('canvas');
    const size = 128; // Larger canvas for better quality
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    
    // Draw background circle with subtle gradient
    const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    gradient.addColorStop(0, `#${color.toString(16).padStart(6, '0')}80`);
    gradient.addColorStop(1, `#${color.toString(16).padStart(6, '0')}`);
    
    ctx.beginPath();
    ctx.arc(size/2, size/2, size/2 - 4, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();
    
    // White border
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 4;
    ctx.stroke();
    
    // Font Awesome icons Unicode
    const iconMap = {
        info: '\uf05a',       // fa-info-circle
        link: '\uf0c1',       // fa-link (chain link icon)
        video: '\uf03d',      // fa-video
        audio: '\uf028',      // fa-volume-up
        warning: '\uf071',    // fa-exclamation-triangle
        question: '\uf059'    // fa-question-circle
    };
    
    // Special styling for link icon to make it more prominent
    if (type === 'link') {
        // Draw a subtle background circle for the icon
        ctx.beginPath();
        ctx.arc(size/2, size/2, size/3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fill();
        
        // Draw the link icon
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 72px "Font Awesome 5 Free"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(iconMap[type], size/2, size/2);
        
        // Add a small external link indicator for link markers
        ctx.beginPath();
        ctx.arc(size - 15, 15, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
        ctx.font = 'bold 12px Arial';
        ctx.fillText('↗', size - 15, 18);
    } else {
        // Draw other icons normally
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 64px "Font Awesome 5 Free"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(iconMap[type], size/2, size/2);
    }
    
    return canvas;
}

        function init() {
            setupEventListeners();
            initThreeJS();
            updateMarkerList();
            updatePlacementStatus();
        }

        function setupEventListeners() {
            document.getElementById('uploadArea').addEventListener('click', () => document.getElementById('fileInput').click());
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            
            // Drag and drop
            document.getElementById('uploadArea').addEventListener('dragover', (e) => {
                e.preventDefault();
                e.currentTarget.style.borderColor = '#90e0ef';
                e.currentTarget.style.background = 'rgba(0, 180, 216, 0.15)';
            });
            document.getElementById('uploadArea').addEventListener('dragleave', (e) => {
                e.currentTarget.style.borderColor = '#00b4d8';
                e.currentTarget.style.background = 'rgba(0, 180, 216, 0.05)';
            });
            document.getElementById('uploadArea').addEventListener('drop', (e) => {
                e.preventDefault();
                e.currentTarget.style.borderColor = '#00b4d8';
                e.currentTarget.style.background = 'rgba(0, 180, 216, 0.05)';
                if (e.dataTransfer.files.length) handleFileSelect(e.dataTransfer.files[0]);
            });

            // Marker type selection
            document.querySelectorAll('.marker-type').forEach(type => {
                type.addEventListener('click', function() {
                    document.querySelectorAll('.marker-type').forEach(t => t.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedMarkerType = this.dataset.type;
                    
                    // Update URL field visibility
                    const urlField = document.getElementById('markerUrl');
                    if (selectedMarkerType === 'link' || selectedMarkerType === 'video' || selectedMarkerType === 'audio') {
                        urlField.classList.remove('hidden');
                    } else {
                        urlField.classList.add('hidden');
                    }
                    
                    // Enter placement mode automatically
                    enablePlacementMode();
                });
            });

            // Buttons
            document.getElementById('placeMarkerBtn').addEventListener('click', enablePlacementMode);
            document.getElementById('saveMarkerBtn').addEventListener('click', saveMarker);
            document.getElementById('cancelMarkerBtn').addEventListener('click', cancelMarker);
            document.getElementById('deleteMarkerBtn').addEventListener('click', deleteCurrentMarker);
            document.getElementById('clearMarkersBtn').addEventListener('click', clearAllMarkers);
            document.getElementById('resetViewBtn').addEventListener('click', resetView);
            document.getElementById('autoRotateBtn').addEventListener('click', toggleAutoRotate);
            document.getElementById('exportBtn').addEventListener('click', showExportModal);
            document.getElementById('copyCodeBtn').addEventListener('click', copyExportCode);
            document.getElementById('downloadBtn').addEventListener('click', downloadExportFile);
            document.getElementById('closeExportBtn').addEventListener('click', () => {
                document.getElementById('exportModal').classList.add('hidden');
            });
            document.getElementById('markerSearch').addEventListener('input', updateMarkerList);
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0.1);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(document.getElementById('viewer').offsetWidth, document.getElementById('viewer').offsetHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('viewer').appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Initialize raycaster and mouse for click detection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            createSphere('https://images.unsplash.com/photo-1519681393784-d120267933ba?w=2048&h=1024&fit=crop');
            setupControls();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

function createSphere(imageUrl) {
    if (sphere) {
        scene.remove(sphere);
        sphere.geometry.dispose();
        sphere.material.dispose();
    }
    
    const geometry = new THREE.SphereGeometry(500, 60, 40);
    geometry.scale(-1, 1, 1);
    
    const texture = new THREE.TextureLoader().load(imageUrl, () => {
        // Only hide instructions if we're not loading the default placeholder
        if (!imageUrl.includes('unsplash.com')) {
            document.getElementById('instructions').classList.add('hidden');
        }
    }, undefined, (error) => {
        console.error('Error loading image:', error);
        alert('Error loading image. Please make sure it\'s a valid image file.');
    });
    
    const material = new THREE.MeshBasicMaterial({ map: texture });
    sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);
}

        function setupControls() {
            const viewer = document.getElementById('viewer');
            
            // Create a target vector for camera to look at
            const target = new THREE.Vector3(0, 0, -1);
            let targetRotation = new THREE.Euler(0, 0, 0, 'YXZ');
            
            viewer.addEventListener('mousedown', (e) => {
                if (placementMode && e.button === 0) { // Left click only in placement mode
                    placeMarkerAtClick(e);
                    return;
                }
                
                isMouseDown = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            viewer.addEventListener('mousemove', (e) => {
                if (!isMouseDown || placementMode) return;
                
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                // Update target rotation
                targetRotation.y -= deltaX * 0.005;
                targetRotation.x -= deltaY * 0.005;
                
                // Limit vertical rotation to prevent flipping
                targetRotation.x = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, targetRotation.x));
                
                // Apply the rotation to a target vector
                const targetVector = new THREE.Vector3(0, 0, -1);
                targetVector.applyEuler(targetRotation);
                
                // Make camera look at the target direction
                camera.lookAt(targetVector);
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            viewer.addEventListener('mouseup', () => { 
                isMouseDown = false; 
            });
            
            viewer.addEventListener('wheel', (e) => {
                if (placementMode) return;
                const zoomFactor = 1 + e.deltaY * 0.001;
                camera.fov *= zoomFactor;
                camera.fov = Math.max(30, Math.min(120, camera.fov));
                camera.updateProjectionMatrix();
            });
            
            // Touch support
            viewer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    if (placementMode) {
                        disablePlacementMode();
                        return;
                    }
                    isMouseDown = true;
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            });
            
            viewer.addEventListener('touchmove', (e) => {
                if (!isMouseDown || e.touches.length !== 1) return;
                e.preventDefault();
                
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;
                
                // Update target rotation
                targetRotation.y -= deltaX * 0.005;
                targetRotation.x -= deltaY * 0.005;
                
                // Limit vertical rotation to prevent flipping
                targetRotation.x = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, targetRotation.x));
                
                // Apply the rotation to a target vector
                const targetVector = new THREE.Vector3(0, 0, -1);
                targetVector.applyEuler(targetRotation);
                
                // Make camera look at the target direction
                camera.lookAt(targetVector);
                
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            });
            
            viewer.addEventListener('touchend', () => { 
                isMouseDown = false; 
            });
            
            // Also update the resetView function to reset the target rotation
            const originalResetView = resetView;
            resetView = function() {
                originalResetView();
                targetRotation.set(0, 0, 0);
                camera.lookAt(new THREE.Vector3(0, 0, -1));
            };
        }

        function enablePlacementMode() {
            if (!currentImageDataUrl) {
                alert('Please upload an image first.');
                return;
            }
            
            placementMode = true;
            document.getElementById('viewer').classList.add('marker-cursor');
            document.getElementById('placementStatus').style.display = 'block';
            document.getElementById('placeMarkerBtn').innerHTML = '<i class="fas fa-times"></i>';
            document.getElementById('placeMarkerBtn').title = 'Exit Placement Mode';
            updatePlacementStatus();
        }

        function disablePlacementMode() {
            placementMode = false;
            document.getElementById('viewer').classList.remove('marker-cursor');
            document.getElementById('placementStatus').style.display = 'none';
            document.getElementById('placeMarkerBtn').innerHTML = '<i class="fas fa-map-marker-alt"></i>';
            document.getElementById('placeMarkerBtn').title = 'Place Marker Mode';
        }

        function updatePlacementStatus() {
            if (placementMode) {
                document.getElementById('placementStatus').innerHTML = `
                    <i class="fas fa-mouse-pointer"></i> <strong>Placing ${selectedMarkerType} marker</strong>
                    <p style="font-size: 0.9rem; margin-top: 5px; color: #aaa;">Click anywhere on the image to place marker</p>
                `;
            }
        }

        function createPreviewMarker(position, type) {
            // Remove any existing preview marker
            removePreviewMarker();
            
            // Create temporary marker for preview
            const canvas = createMarkerIcon(type, markerTypes[type].color);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.7,
                depthWrite: false,
                depthTest: false,
                alphaTest: 0.1
            });
            
            previewMarker = new THREE.Sprite(spriteMaterial);
            previewMarker.position.copy(position);
            previewMarker.scale.set(30, 30, 1);
            previewMarker.renderOrder = 998; // Slightly behind final markers
            
            scene.add(previewMarker);
            return previewMarker;
        }

        function removePreviewMarker() {
            if (previewMarker) {
                scene.remove(previewMarker);
                if (previewMarker.material) {
                    if (previewMarker.material.map) previewMarker.material.map.dispose();
                    previewMarker.material.dispose();
                }
                previewMarker = null;
            }
        }

        function placeMarkerAtClick(event) {
            if (!placementMode || !currentImageDataUrl) return;
            
            // Calculate mouse position in normalized device coordinates
            const rect = document.getElementById('viewer').getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Calculate intersection with sphere
            const intersects = raycaster.intersectObject(sphere);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const position = intersect.point;
                
                // Create preview marker immediately
                createPreviewMarker(position, selectedMarkerType);
                
                // Create new marker data
                editingMarkerId = null;
                currentMarker = {
                    id: Date.now(),
                    type: selectedMarkerType,
                    title: `${selectedMarkerType.charAt(0).toUpperCase() + selectedMarkerType.slice(1)} Marker ${markers.length + 1}`,
                    description: '',
                    url: '',
                    position: position.toArray()
                };
                
                // Open marker form
                document.getElementById('markerTitle').value = currentMarker.title;
                document.getElementById('markerDescription').value = '';
                document.getElementById('markerUrl').value = '';
                document.getElementById('deleteMarkerBtn').style.display = 'none';
                
                // Update URL field visibility based on selected type
                const urlField = document.getElementById('markerUrl');
                if (selectedMarkerType === 'link' || selectedMarkerType === 'video' || selectedMarkerType === 'audio') {
                    urlField.classList.remove('hidden');
                } else {
                    urlField.classList.add('hidden');
                }
                
                document.getElementById('markerForm').classList.remove('hidden');
                document.getElementById('markerTitle').focus();
                
                // Exit placement mode
                disablePlacementMode();
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) handleFileSelect(file);
        }

        function handleFileSelect(file) {
            if (!file.type.match('image.*')) {
                alert('Please select an image file (JPG, PNG, etc.)');
                return;
            }
            
            currentImageName = file.name;
            const reader = new FileReader();
            reader.onload = function(e) {
                currentImageDataUrl = e.target.result;
                createSphere(currentImageDataUrl);
                document.getElementById('currentImageName').textContent = currentImageName;
                document.getElementById('imageInfo').classList.remove('hidden');
                document.getElementById('instructions').classList.add('hidden');
                // Clear existing markers from scene but keep in array for re-creation
                markers.forEach(marker => {
                    if (marker.object) {
                        scene.remove(marker.object);
                    }
                });
                // Re-create markers with new image
                markers.forEach(marker => {
                    createMarkerObject(marker);
                });
                updateMarkerList();
                // Exit placement mode if active
                if (placementMode) {
                    disablePlacementMode();
                }
                // Remove preview marker if it exists
                removePreviewMarker();
            };
            reader.onerror = function() { alert('Error reading file. Please try again.'); };
            reader.readAsDataURL(file);
        }

        function createMarkerObject(marker) {
            // Create billboard sprite with icon
            const canvas = createMarkerIcon(marker.type, markerTypes[marker.type].color);
            const texture = new THREE.CanvasTexture(canvas);
            
            // Create sprite material with FIXED rendering settings
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,  // FIX: Don't write to depth buffer
                depthTest: false,   // FIX: Don't test depth (render always)
                alphaTest: 0.1      // FIX: Use alpha test for better transparency
            });
            
            // Create sprite (billboard that always faces camera)
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(...marker.position);
            sprite.scale.set(30, 30, 1);
            sprite.userData = { markerId: marker.id };
            
            // FIX: Set render order to ensure it renders on top
            sprite.renderOrder = 999;
            
            scene.add(sprite);
            
            marker.object = sprite;
            return sprite;
        }

        function saveMarker() {
            const title = document.getElementById('markerTitle').value.trim();
            const description = document.getElementById('markerDescription').value.trim();
            const url = document.getElementById('markerUrl').value.trim();
            
            if (!title) {
                alert('Please enter a marker title.');
                return;
            }
            
            currentMarker.title = title;
            currentMarker.description = description;
            currentMarker.url = url;
            
            // Remove preview marker
            removePreviewMarker();
            
            if (editingMarkerId) {
                // Update existing marker
                const index = markers.findIndex(m => m.id === editingMarkerId);
                if (index !== -1) {
                    // Remove old marker from scene
                    if (markers[index].object) {
                        scene.remove(markers[index].object);
                    }
                    // Update marker data
                    markers[index] = {...currentMarker};
                    // Create new marker object
                    createMarkerObject(markers[index]);
                }
            } else {
                // Create new marker
                createMarkerObject(currentMarker);
                markers.push(currentMarker);
            }
            
            cancelMarker();
            updateMarkerList();
        }

        function cancelMarker() {
            // Remove preview marker if it exists
            removePreviewMarker();
            
            editingMarkerId = null;
            currentMarker = null;
            document.getElementById('markerForm').classList.add('hidden');
            document.getElementById('markerTitle').value = '';
            document.getElementById('markerDescription').value = '';
            document.getElementById('markerUrl').value = '';
            document.getElementById('deleteMarkerBtn').style.display = 'none';
        }

        function deleteCurrentMarker() {
            if (!editingMarkerId || !confirm('Are you sure you want to delete this marker?')) return;
            
            const index = markers.findIndex(m => m.id === editingMarkerId);
            if (index !== -1) {
                // Remove from scene
                if (markers[index].object) {
                    scene.remove(markers[index].object);
                }
                // Remove from array
                markers.splice(index, 1);
                updateMarkerList();
                cancelMarker();
            }
        }

        function editMarker(marker) {
            // Remove any preview marker
            removePreviewMarker();
            
            editingMarkerId = marker.id;
            currentMarker = {...marker};
            
            document.getElementById('markerTitle').value = marker.title;
            document.getElementById('markerDescription').value = marker.description || '';
            document.getElementById('markerUrl').value = marker.url || '';
            document.getElementById('deleteMarkerBtn').style.display = 'block';
            
            // Update type selector
            document.querySelectorAll('.marker-type').forEach(t => t.classList.remove('selected'));
            document.querySelector(`.marker-type[data-type="${marker.type}"]`).classList.add('selected');
            selectedMarkerType = marker.type;
            
            // Update URL field visibility
            const urlField = document.getElementById('markerUrl');
            if (marker.type === 'link' || marker.type === 'video' || marker.type === 'audio') {
                urlField.classList.remove('hidden');
            } else {
                urlField.classList.add('hidden');
            }
            
            document.getElementById('markerForm').classList.remove('hidden');
            document.getElementById('markerTitle').focus();
        }

        function updateMarkerList() {
            const markerList = document.getElementById('markerList');
            const searchTerm = document.getElementById('markerSearch').value.toLowerCase();
            const filteredMarkers = markers.filter(marker => 
                marker.title.toLowerCase().includes(searchTerm) ||
                marker.description.toLowerCase().includes(searchTerm) ||
                marker.type.includes(searchTerm)
            );
            
            markerList.innerHTML = '';
            filteredMarkers.forEach(marker => {
                const markerItem = document.createElement('div');
                markerItem.className = 'marker-item';
                markerItem.innerHTML = `
                    <div class="marker-item-header">
                        <div class="marker-item-title">
                            <i class="fas ${markerTypes[marker.type].icon}"></i>
                            ${marker.title}
                        </div>
                        <span class="marker-item-type">${marker.type}</span>
                    </div>
                    <div class="marker-item-description">${marker.description || 'No description'}</div>
                    <div class="marker-item-actions">
                        <button class="marker-action-btn edit" data-id="${marker.id}">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="marker-action-btn delete" data-id="${marker.id}">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                    </div>
                `;
                
                // Click on marker item to view it
                markerItem.addEventListener('click', (e) => {
                    // Don't trigger if clicking action buttons
                    if (e.target.closest('.marker-action-btn')) return;
                    
                    const markerObj = marker.object;
                    if (markerObj) {
                        const markerPosition = markerObj.position.clone();
                        const direction = markerPosition.clone().normalize();
                        camera.position.copy(direction.multiplyScalar(0.1));
                        camera.lookAt(markerObj.position);
                    }
                    showMarkerInfo(marker);
                });
                
                // Edit button
                const editBtn = markerItem.querySelector('.marker-action-btn.edit');
                editBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    editMarker(marker);
                });
                
                // Delete button
                const deleteBtn = markerItem.querySelector('.marker-action-btn.delete');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm(`Are you sure you want to delete "${marker.title}"?`)) {
                        const index = markers.findIndex(m => m.id === marker.id);
                        if (index !== -1) {
                            // Remove from scene
                            if (markers[index].object) {
                                scene.remove(markers[index].object);
                            }
                            // Remove from array
                            markers.splice(index, 1);
                            updateMarkerList();
                        }
                    }
                });
                
                markerList.appendChild(markerItem);
            });
            
            document.getElementById('markerCount').textContent = markers.length;
            document.getElementById('markerListCount').textContent = markers.length;
        }

        function showMarkerInfo(marker) {
            // Remove any existing info panel
            removeInfoPanel();
            
            // Create new info panel
            const infoPanel = document.createElement('div');
            infoPanel.className = 'marker-info-panel';
            
            let content = `<button class="close-btn">&times;</button>
                          <h4><i class="fas ${markerTypes[marker.type].icon}"></i> ${marker.title}</h4>
                          <p><strong>Type:</strong> ${marker.type}</p>`;
            
            if (marker.description) {
                content += `<p><strong>Description:</strong><br>${marker.description}</p>`;
            }
            
            if (marker.url) {
                let linkText = 'Open Link';
                if (marker.type === 'video') linkText = 'Watch Video';
                else if (marker.type === 'audio') linkText = 'Play Audio';
                
                content += `<a href="${marker.url}" target="_blank">${linkText} <i class="fas fa-external-link-alt"></i></a>`;
            }
            
            infoPanel.innerHTML = content;
            
            // Add close button functionality
            const closeBtn = infoPanel.querySelector('.close-btn');
            closeBtn.addEventListener('click', () => {
                removeInfoPanel();
            });
            
            // Position the panel near the marker on screen
            positionInfoPanelAtMarker(infoPanel, marker);
            
            // Add to viewer container
            document.querySelector('.viewer-container').appendChild(infoPanel);
            activeInfoPanel = infoPanel;
            
            // Auto-close after 10 seconds
            setTimeout(() => {
                if (activeInfoPanel === infoPanel) {
                    removeInfoPanel();
                }
            }, 10000);
        }

        function positionInfoPanelAtMarker(panel, marker) {
            const markerPosition = new THREE.Vector3(...marker.position);
            const vector = markerPosition.clone();
            
            // Project 3D position to 2D screen coordinates
            vector.project(camera);
            
            const viewerRect = document.getElementById('viewer').getBoundingClientRect();
            const x = (vector.x * 0.5 + 0.5) * viewerRect.width;
            const y = (-vector.y * 0.5 + 0.5) * viewerRect.height;
            
            // Position panel near marker, adjusting if near edges
            let left = x + 20;
            let top = y + 20;
            
            // Adjust if panel would go off screen
            const panelWidth = panel.offsetWidth || 250;
            const panelHeight = panel.offsetHeight || 200;
            
            if (left + panelWidth > viewerRect.width) {
                left = x - panelWidth - 20;
            }
            
            if (top + panelHeight > viewerRect.height) {
                top = y - panelHeight - 20;
            }
            
            // Ensure panel stays within bounds
            left = Math.max(10, Math.min(viewerRect.width - panelWidth - 10, left));
            top = Math.max(10, Math.min(viewerRect.height - panelHeight - 10, top));
            
            panel.style.left = left + 'px';
            panel.style.top = top + 'px';
        }

        function removeInfoPanel() {
            if (activeInfoPanel) {
                activeInfoPanel.remove();
                activeInfoPanel = null;
            }
        }

        function clearAllMarkers() {
            if (markers.length === 0) return;
            if (confirm(`Are you sure you want to remove all ${markers.length} markers?`)) {
                markers.forEach(marker => {
                    if (marker.object) {
                        scene.remove(marker.object);
                        if (marker.object.material) {
                            if (marker.object.material.map) marker.object.material.map.dispose();
                            marker.object.material.dispose();
                        }
                    }
                });
                markers = [];
                updateMarkerList();
                removeInfoPanel();
                // Remove preview marker if it exists
                removePreviewMarker();
            }
        }

        function resetView() {
            camera.rotation.set(0, 0, 0);
            camera.fov = 75;
            camera.updateProjectionMatrix();
            removeInfoPanel();
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('autoRotateBtn');
            btn.innerHTML = autoRotate ? 
                '<i class="fas fa-stop-circle"></i> Stop Auto-Rotate' : 
                '<i class="fas fa-sync"></i> Toggle Auto-Rotate';
        }

        function showExportModal() {
            if (!currentImageDataUrl) {
                alert('Please upload an image first.');
                return;
            }
            
            if (markers.length === 0) {
                if (!confirm('No markers added. Export image only?')) return;
            }
            
            document.getElementById('exportCode').value = generateExportCode();
            document.getElementById('exportModal').classList.remove('hidden');
        }

        function generateExportCode() {
            const markerData = markers.map(marker => ({
                type: marker.type,
                title: marker.title,
                description: marker.description,
                url: marker.url,
                position: marker.position,
                color: markerTypes[marker.type].color
            }));
            
            // Simple HTML escape function
            function escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            const safeImageName = escapeHtml(currentImageName);
            const markerJson = JSON.stringify(markerData);
            
            // Build the export HTML with IN-WORLD marker info panels
            return '<!DOCTYPE html>\n' +
'<html lang="en">\n' +
'<head>\n' +
'    <meta charset="UTF-8">\n' +
'    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n' +
'    <title>360° Viewer: ' + safeImageName + '</title>\n' +
'    <style>\n' +
'        body { margin: 0; overflow: hidden; background: #000; font-family: \'Segoe UI\', Tahoma, Geneva, Verdana, sans-serif; }\n' +
'        canvas { display: block; }\n' +
'        .marker-info-panel { \n' +
'            position: absolute; \n' +
'            background: rgba(0,0,0,0.9); \n' +
'            color: white; \n' +
'            padding: 15px;\n' +
'            border-radius: 8px;\n' +
'            border-left: 4px solid #00b4d8;\n' +
'            max-width: 300px;\n' +
'            min-width: 250px;\n' +
'            box-shadow: 0 5px 15px rgba(0,0,0,0.5);\n' +
'            z-index: 1000;\n' +
'            pointer-events: auto;\n' +
'            backdrop-filter: blur(5px);\n' +
'            transition: opacity 0.3s ease;\n' +
'            font-size: 14px;\n' +
'        }\n' +
'        .marker-info-panel h4 {\n' +
'            color: #00b4d8;\n' +
'            margin: 0 0 10px 0;\n' +
'            font-size: 16px;\n' +
'        }\n' +
'        .marker-info-panel a {\n' +
'            color: #4cc9f0;\n' +
'            text-decoration: none;\n' +
'            display: inline-block;\n' +
'            margin-top: 10px;\n' +
'            padding: 6px 12px;\n' +
'            background: rgba(76, 201, 240, 0.1);\n' +
'            border-radius: 4px;\n' +
'        }\n' +
'        .marker-info-panel .close-btn {\n' +
'            position: absolute;\n' +
'            top: 5px;\n' +
'            right: 5px;\n' +
'            background: transparent;\n' +
'            border: none;\n' +
'            color: #aaa;\n' +
'            cursor: pointer;\n' +
'            font-size: 18px;\n' +
'            width: 24px;\n' +
'            height: 24px;\n' +
'            display: flex;\n' +
'            align-items: center;\n' +
'            justify-content: center;\n' +
'            border-radius: 50%;\n' +
'        }\n' +
'        .instructions {\n' +
'            position: absolute;\n' +
'            top: 50%;\n' +
'            left: 50%;\n' +
'            transform: translate(-50%, -50%);\n' +
'            text-align: center;\n' +
'            background: rgba(0, 0, 0, 0.9);\n' +
'            color: white;\n' +
'            padding: 30px;\n' +
'            border-radius: 10px;\n' +
'            max-width: 500px;\n' +
'            border: 2px solid #00b4d8;\n' +
'        }\n' +
'        .hidden { display: none; }\n' +
'        #startBtn {\n' +
'            margin-top: 15px; \n' +
'            padding: 10px 20px; \n' +
'            background: #00b4d8; \n' +
'            color: white; \n' +
'            border: none; \n' +
'            border-radius: 5px; \n' +
'            cursor: pointer;\n' +
'            font-weight: bold;\n' +
'        }\n' +
'    </style>\n' +
'</head>\n' +
'<body>\n' +
'    <div id="container"></div>\n' +
'    \n' +
'    <div class="instructions" id="instructions">\n' +
'        <h3 style="color: #00b4d8; margin-top: 0;">360° Image Viewer</h3>\n' +
'        <p><strong>' + safeImageName + '</strong></p>\n' +
'        <p>Drag to look around • Scroll to zoom</p>\n' +
'        <p>Click on markers for information</p>\n' +
'        <button id="startBtn">Start Exploring</button>\n' +
'    </div>\n' +
'\n' +
'    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>\n' +
'    <script>\n' +
'        const scene = new THREE.Scene();\n' +
'        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n' +
'        const renderer = new THREE.WebGLRenderer({ antialias: true });\n' +
'        renderer.setSize(window.innerWidth, window.innerHeight);\n' +
'        document.getElementById("container").appendChild(renderer.domElement);\n' +
'        \n' +
'        const geometry = new THREE.SphereGeometry(500, 60, 40);\n' +
'        geometry.scale(-1, 1, 1);\n' +
'        \n' +
'        const textureLoader = new THREE.TextureLoader();\n' +
'        const texture = textureLoader.load("' + currentImageDataUrl + '", \n' +
'            function() {\n' +
'                document.getElementById("instructions").classList.remove("hidden");\n' +
'            },\n' +
'            undefined,\n' +
'            function(error) {\n' +
'                console.error("Error loading image:", error);\n' +
'            }\n' +
'        );\n' +
'        \n' +
'        const material = new THREE.MeshBasicMaterial({ map: texture });\n' +
'        const sphere = new THREE.Mesh(geometry, material);\n' +
'        scene.add(sphere);\n' +
'        \n' +
'        const markers = ' + markerJson + ';\n' +
'        let activeInfoPanel = null;\n' +
'        \n' +
'        markers.forEach(marker => {\n' +
'            // Create icon on canvas\n' +
'            const iconCanvas = document.createElement("canvas");\n' +
'            const iconSize = 64;\n' +
'            iconCanvas.width = iconSize;\n' +
'            iconCanvas.height = iconSize;\n' +
'            const iconCtx = iconCanvas.getContext("2d");\n' +
'            \n' +
'            // Draw icon background\n' +
'            iconCtx.beginPath();\n' +
'            iconCtx.arc(iconSize/2, iconSize/2, iconSize/2 - 4, 0, Math.PI * 2);\n' +
'            iconCtx.fillStyle = "#" + marker.color.toString(16).padStart(6, "0");\n' +
'            iconCtx.fill();\n' +
'            iconCtx.strokeStyle = "#ffffff";\n' +
'            iconCtx.lineWidth = 3;\n' +
'            iconCtx.stroke();\n' +
'            \n' +
'            // Draw Font Awesome icon\n' +
'            iconCtx.fillStyle = "white";\n' +
'            iconCtx.font = "bold 32px Arial";\n' +
'            iconCtx.textAlign = "center";\n' +
'            iconCtx.textBaseline = "middle";\n' +
'            \n' +
'            const iconChar = {\n' +
'                info: "ⓘ",\n' +
'                link: "🔗",\n' +
'                video: "▶",\n' +
'                audio: "♪",\n' +
'                warning: "⚠",\n' +
'                question: "?"\n' +
'            }[marker.type];\n' +
'            \n' +
'            iconCtx.fillText(iconChar, iconSize/2, iconSize/2);\n' +
'            // Create sprite\n' +
'            const markerTexture = new THREE.CanvasTexture(iconCanvas);\n' +
'            const spriteMaterial = new THREE.SpriteMaterial({ \n' +
'                map: markerTexture,\n' +
'                transparent: true,\n' +
'                opacity: 0.9,\n' +
'                depthWrite: false,\n' +
'                depthTest: false,\n' +
'                alphaTest: 0.1\n' +
'            });\n' +
'            const sprite = new THREE.Sprite(spriteMaterial);\n' +
'            sprite.position.set(marker.position[0], marker.position[1], marker.position[2]);\n' +
'            sprite.scale.set(30, 30, 1);\n' +
'            sprite.userData = marker;\n' +
'            sprite.renderOrder = 999;\n' +
'            scene.add(sprite);\n' +
'        });\n' +
'        \n' +
'        camera.position.set(0, 0, 0.1);\n' +
'        \n' +
'        let isMouseDown = false;\n' +
'        let previousMousePosition = { x: 0, y: 0 };\n' +
'        let targetRotation = new THREE.Euler(0, 0, 0, "YXZ");\n' +
'        \n' +
'        document.addEventListener("mousedown", (e) => {\n' +
'            isMouseDown = true;\n' +
'            previousMousePosition = { x: e.clientX, y: e.clientY };\n' +
'        });\n' +
'        \n' +
'        document.addEventListener("mousemove", (e) => {\n' +
'            if (!isMouseDown) return;\n' +
'            \n' +
'            const deltaX = e.clientX - previousMousePosition.x;\n' +
'            const deltaY = e.clientY - previousMousePosition.y;\n' +
'            \n' +
'            targetRotation.y -= deltaX * 0.005;\n' +
'            targetRotation.x -= deltaY * 0.005;\n' +
'            targetRotation.x = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, targetRotation.x));\n' +
'            \n' +
'            const targetVector = new THREE.Vector3(0, 0, -1);\n' +
'            targetVector.applyEuler(targetRotation);\n' +
'            camera.lookAt(targetVector);\n' +
'            \n' +
'            previousMousePosition = { x: e.clientX, y: e.clientY };\n' +
'        });\n' +
'        \n' +
'        document.addEventListener("mouseup", () => { isMouseDown = false; });\n' +
'        \n' +
'        document.addEventListener("wheel", (e) => {\n' +
'            const zoomFactor = 1 + e.deltaY * 0.001;\n' +
'            camera.fov *= zoomFactor;\n' +
'            camera.fov = Math.max(30, Math.min(120, camera.fov));\n' +
'            camera.updateProjectionMatrix();\n' +
'        });\n' +
'        \n' +
'        // Touch support\n' +
'        document.addEventListener("touchstart", (e) => {\n' +
'            if (e.touches.length === 1) {\n' +
'                isMouseDown = true;\n' +
'                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };\n' +
'            }\n' +
'        });\n' +
'        \n' +
'        document.addEventListener("touchmove", (e) => {\n' +
'            if (!isMouseDown || e.touches.length !== 1) return;\n' +
'            e.preventDefault();\n' +
'            \n' +
'            const deltaX = e.touches[0].clientX - previousMousePosition.x;\n' +
'            const deltaY = e.touches[0].clientY - previousMousePosition.y;\n' +
'            \n' +
'            targetRotation.y -= deltaX * 0.005;\n' +
'            targetRotation.x -= deltaY * 0.005;\n' +
'            targetRotation.x = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, targetRotation.x));\n' +
'            \n' +
'            const targetVector = new THREE.Vector3(0, 0, -1);\n' +
'            targetVector.applyEuler(targetRotation);\n' +
'            camera.lookAt(targetVector);\n' +
'            \n' +
'            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };\n' +
'        });\n' +
'        \n' +
'        document.addEventListener("touchend", () => { isMouseDown = false; });\n' +
'        \n' +
'        const raycaster = new THREE.Raycaster();\n' +
'        const mouse = new THREE.Vector2();\n' +
'        \n' +
'        function removeInfoPanel() {\n' +
'            if (activeInfoPanel) {\n' +
'                activeInfoPanel.remove();\n' +
'                activeInfoPanel = null;\n' +
'            }\n' +
'        }\n' +
'        \n' +
'        function positionInfoPanelAtMarker(panel, marker) {\n' +
'            const markerPosition = new THREE.Vector3(marker.position[0], marker.position[1], marker.position[2]);\n' +
'            const vector = markerPosition.clone();\n' +
'            vector.project(camera);\n' +
'            \n' +
'            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;\n' +
'            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;\n' +
'            \n' +
'            let left = x + 20;\n' +
'            let top = y + 20;\n' +
'            \n' +
'            const panelWidth = panel.offsetWidth || 250;\n' +
'            const panelHeight = panel.offsetHeight || 200;\n' +
'            \n' +
'            if (left + panelWidth > window.innerWidth) left = x - panelWidth - 20;\n' +
'            if (top + panelHeight > window.innerHeight) top = y - panelHeight - 20;\n' +
'            \n' +
'            left = Math.max(10, Math.min(window.innerWidth - panelWidth - 10, left));\n' +
'            top = Math.max(10, Math.min(window.innerHeight - panelHeight - 10, top));\n' +
'            \n' +
'            panel.style.left = left + "px";\n' +
'            panel.style.top = top + "px";\n' +
'        }\n' +
'        \n' +
'        function onMouseClick(event) {\n' +
'            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n' +
'            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n' +
'            raycaster.setFromCamera(mouse, camera);\n' +
'            const markerObjects = scene.children.filter(obj => obj !== sphere);\n' +
'            const intersects = raycaster.intersectObjects(markerObjects);\n' +
'            if (intersects.length > 0) {\n' +
'                const marker = intersects[0].object.userData;\n' +
'                removeInfoPanel();\n' +
'                \n' +
'                const infoPanel = document.createElement("div");\n' +
'                infoPanel.className = "marker-info-panel";\n' +
'                \n' +
'                let content = \'<button class="close-btn">&times;</button>\';\n' +
'                content += \'<h4>\' + marker.title + \'</h4>\';\n' +
'                content += \'<p><strong>Type:</strong> \' + marker.type + \'</p>\';\n' +
'                if (marker.description) {\n' +
'                    content += \'<p><strong>Description:</strong><br>\' + marker.description + \'</p>\';\n' +
'                }\n' +
'                if (marker.url) {\n' +
'                    let linkText = "Open Link";\n' +
'                    if (marker.type === "video") linkText = "Watch Video";\n' +
'                    else if (marker.type === "audio") linkText = "Play Audio";\n' +
'                    content += \'<a href="\' + marker.url + \'" target="_blank">\' + linkText + \'</a>\';\n' +
'                }\n' +
'                \n' +
'                infoPanel.innerHTML = content;\n' +
'                document.body.appendChild(infoPanel);\n' +
'                activeInfoPanel = infoPanel;\n' +
'                \n' +
'                // Position panel\n' +
'                positionInfoPanelAtMarker(infoPanel, marker);\n' +
'                \n' +
'                // Add close button functionality\n' +
'                infoPanel.querySelector(".close-btn").addEventListener("click", removeInfoPanel);\n' +
'                \n' +
'                // Auto-close after 10 seconds\n' +
'                setTimeout(() => {\n' +
'                    if (activeInfoPanel === infoPanel) removeInfoPanel();\n' +
'                }, 10000);\n' +
'            } else {\n' +
'                removeInfoPanel();\n' +
'            }\n' +
'        }\n' +
'        \n' +
'        document.addEventListener("click", onMouseClick);\n' +
'        \n' +
'        document.getElementById("startBtn").addEventListener("click", () => {\n' +
'            document.getElementById("instructions").classList.add("hidden");\n' +
'        });\n' +
'        \n' +
'        setTimeout(() => {\n' +
'            document.getElementById("instructions").classList.add("hidden");\n' +
'        }, 5000);\n' +
'        \n' +
'        window.addEventListener("resize", () => {\n' +
'            camera.aspect = window.innerWidth / window.innerHeight;\n' +
'            camera.updateProjectionMatrix();\n' +
'            renderer.setSize(window.innerWidth, window.innerHeight);\n' +
'        });\n' +
'        \n' +
'        function animate() {\n' +
'            requestAnimationFrame(animate);\n' +
'            renderer.render(scene, camera);\n' +
'        }\n' +
'        animate();\n' +
'    <\/script>\n' +
'</body>\n' +
'</html>';
        }

        function copyExportCode() {
            const exportCode = document.getElementById('exportCode');
            exportCode.select();
            exportCode.setSelectionRange(0, 99999);
            try {
                document.execCommand('copy');
                alert('Code copied to clipboard! Save it as an HTML file.');
            } catch (err) {
                console.error('Failed to copy: ', err);
                alert('Failed to copy code. Please select and copy manually.');
            }
        }

        function downloadExportFile() {
            const exportCode = document.getElementById('exportCode').value;
            const blob = new Blob([exportCode], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const safeFilename = currentImageName.replace(/\.[^/.]+$/, "") || 'export';
            a.download = `360-viewer-${safeFilename}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function onWindowResize() {
            camera.aspect = document.getElementById('viewer').offsetWidth / document.getElementById('viewer').offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(document.getElementById('viewer').offsetWidth, document.getElementById('viewer').offsetHeight);
            
            // Reposition active info panel if it exists
            if (activeInfoPanel) {
                const markerId = activeInfoPanel.dataset.markerId;
                if (markerId) {
                    const marker = markers.find(m => m.id.toString() === markerId);
                    if (marker) {
                        positionInfoPanelAtMarker(activeInfoPanel, marker);
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (autoRotate) {
                camera.rotation.y += 0.002;
                camera.rotation.x = Math.max(-Math.PI/4, Math.min(Math.PI/4, camera.rotation.x));
            }
            
            renderer.render(scene, camera);
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
